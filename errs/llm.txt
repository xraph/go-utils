# errs - Generic Error Handling Package

## Purpose

Production-ready, extensible error handling package for Go with interface-based design. Provides structured errors with error codes, context enrichment, and optional HTTP response mapping. Designed to be a generic foundation for all Go projects with zero external dependencies.

## Key Components

- **Core Interfaces**: ContextualError, CodedError, HTTPResponder, CausedError
- **Error Type**: Structured error implementing all core interfaces
- **HTTPError**: HTTP-aware errors with status codes for REST APIs
- **Error Codes**: Generic type-safe constants that can be extended
- **Sentinel Errors**: Predefined error instances for pattern matching with `errors.Is`
- **Helper Functions**: Convenience methods for common error checks
- **Error Wrapping**: Full chain traversal support for wrapped errors

## Architecture

```
Interface Hierarchy
├── ContextualError (add/get context)
├── CodedError (structured error codes)
├── HTTPResponder (HTTP response mapping)
└── CausedError (explicit error chain)

Concrete Types
├── Error (implements all interfaces)
│   ├── Code (string constant)
│   ├── Message (human-readable)
│   ├── Cause (wrapped error)
│   ├── Timestamp
│   └── Ctx (metadata map)
└── HTTPError (implements error, HTTPResponder)
    ├── Code (HTTP status)
    ├── Message
    └── Err (wrapped error)

Error Chain Support
└── errors.Is, errors.As, errors.Unwrap
```

## Public API

### Core Interfaces

```go
// ContextualError adds key-value context to errors
type ContextualError interface {
    error
    WithContext(key string, value any) ContextualError
    GetContext() map[string]any
}

// CodedError provides structured error codes
type CodedError interface {
    error
    GetCode() string
}

// HTTPError enables HTTP response generation
// This is the primary interface for HTTP-compatible errors
type HTTPError interface {
    error
    StatusCode() int
    ResponseBody() any
}

// CausedError provides explicit error chain access
type CausedError interface {
    error
    Unwrap() error
    Cause() error
}
```

### Core Types

```go
type Error struct {
    Code      string         // Error code constant (e.g., "NOT_FOUND")
    Message   string         // Human-readable message
    Err       error          // Underlying error (can be nil)
    Timestamp time.Time      // When the error occurred
    Ctx       map[string]any // Additional context for debugging
}

type HTTPError struct {
    Code    int    // HTTP status code (e.g., 404, 500)
    Message string // Error message
    ENewError(code, message string, cause error) *Error
func ErrNotFound(resource string) *Error
func ErrAlreadyExists(resource string) *Error
func ErrValidation(message string, cause error) *Error
func ErrInvalidInput(field string, reason string) *Error
func ErrTimeout(operation string, duration time.Duration) *Error
func ErrCancelled(operation string) *Error
func ErrInternal(message string, cause error) *Error

// HTTP errors - return HTTPError interface
func NewHTTPError(code int, message string) HTTPError
func BadRequest(message string) HTTPError
func Unauthorized(message string) HTTPError
func Forbidden(message string) HTTPError
func NotFound(message string) HTTPError
func InternalError(err error) HTTPError

// Error checking helpers
func IsNotFound(err error) bool
func IsAlreadyExists(err error) bool
func IsValidation(err error) bool
func IsTimeout(err error) bool
func IsCancelled(err error) bool

// HTTP status extraction
func GetHTTPStatusCode(err error) int

// Standard library wrappers
func Is(err, target error) bool
func As(err error, target any
// Constructor functions (recommended)
func ErrServiceNotFound(service string) *ForgeError
func ErrServiceAlreadyExists(service string) *ForgeError
func ErrValidationError(field string, cause error) *ForgeError
func ErrConfigError(message string, cause error) *ForgeError
func ErrTimeoutError(operation string, timeout time.Duration) *ForgeError

// HTTP ers.ErrNotFound("user")
err := errs.ErrValidation("invalid email format", fmt.Errorf("missing @ symbol"))
err := errs.ErrTimeout("database query", 5*time.Second)

// With additional context (fluent API)
err := errs.ErrNotFound("cache_entry").
    WithContext("key", "user:123").
    WithContext("namespace", "sessions").
    WithContext("retry_count", 3)

// Create custom errors with your own codes
err := errs.NewError("CUSTOM_CODE", "something went wrong", nil)

// HTTP errors
err := errs.BadRequest("missing required field: email")
err := errs.Unauthorized("invalid or expired token")
err := errs.NotFound("resource not found")
```

### Error Checking with Sentinel Errors

```go
// Using sentinel errors (most concise)
if errs.Is(err, errs.ErrNotFoundSentinel) {
    log.Println("Resource not found, using default")
    // Handle not found
}

// Using helper functions (clearest intent)
if errs.IsNotFound(err) {
    return errs.NotFound("user not found")
}

if errs.IsTimeout(err) {
    return errs.BadRequest("request took too long")
}

// Using interfaces (most extensible)
if codedErr, ok := err.(errs.CodedError); ok {
    log.Printf("Error code: %s", codedErr.GetCode()
err := errors.ErrValidationError("email", fmt.Errorf("invalid format"))
err := errors.ErrTimeoutError("query", 5*time.Second)

// With additional context
err := errors.ErrServiceNotFound("cache").
    WithContext("host", "localhost").
    WithContext("port", 6379).
    WithContext("retry_count", 3)

// HTTP errors
err := errors.BadRequest("missing required field: email")
err := errors.Unauthorized("invalid or expired token")
err := errors.NotFound("user not found")
```

### Error Checking with Sentinel Errors

```go
// Using sentinel errors (most concise)
if errors.Is(err, errors.ErrServiceNotFoundSentinel) {
    log.Println("Service not available, using fallback")
    // Handle service not found
}

// Using helper functions (clearest intent)
if errors.IsServiceNotFound(err) {
    return errs.ErrNotFound("user")
wrappedErr := errs.ErrInternal("database query failed", baseErr)

// Check if any error in the chain matches
if errs.Is(wrappedErr, errs.ErrNotFoundSentinel) {
    // This matches even though it's wrapped
    log.Println("User not found in the chain")
}

// Extract specific error type from chain
var structuredErr *errs.Error
if errs.As(wrappedErr, &structuredErr) {
    log.Printf("Code: %s, Context: %v", structuredErr.Code, structuredErr.Ctx)
}

// Access context from errors using interface
if contextualErr, ok := err.(errs.ContextualError); ok {
    ctx := contextualErr.GetContext()
    if userID, exists := ctx["user_id"]; exists {
        log.Printf("Error related to user: %v", userID)
    }
}

// Traverse error chain
for err := wrappedErr; err != nil; err = erin ConfigError
    log.Println("Autw http.ResponseWriter, r *http.Request) {
    user, err := userService.GetUser(r.Context(), userID)
    if err != nil {
        // Automatic status code mapping
        statusCode := errs.GetHTTPStatusCode(err)
        http.Error(w, err.Error(), statusCode)
        return
    }
    json.NewEncoder(w).Encode(user)
}

// Create HTTP errors
func validateInput(data *UserInput) error {
    if data.Email == "" {
        return errs.BadRequest("email is required")
    }
    if !isValidEmail(data.Email) {
        return errs.BadRequest("invalid email format")
    }
    return nil
}
```

### Error Context for Debugging

```go
func connectToDatabase(config DBConfig) error {
    conn, err := sql.Open("postgres", config.DSN)
    if err != nil {
        // Add rich context for debugging
        return errs.ErrInternal("database connection failed", err).
            WithContext("host", config.Host).
            WithContext("port", config.Port).
            WithContext("database", config.Database).
            WithContext("ssl_mode", config.SSLMode).
            WithContext("max_connections", config.MaxConnections).(*errs.Error)
    }
    return nil
}

// Later, when logging the error
var structuredErr *errs.Error
if errs.As(err, &structuredErr) {
    log.Printf("Error Code: %s", structuredErr.Code)
    log.Printf("Message: %s", structuredErr.Message)
    log.Printf("Timestamp: %s", structuredErr.Timestamp)
    log.Printf("Context: %+v", structuredErr.CtxN)
    if err != nil {
        // Add rich context for debugging
        return errors.ErrConfigError("database connection failed", err).
            WithContext("host", config.Host).
    Extending with Custom Error Types

```go
// Define your own error codes
const (
    CodeDatabaseError    = "DATABASE_ERROR"
    CodeCacheError       = "CACHE_ERROR"
    CodeExternalAPIError = "EXTERNAL_API_ERROR"
)

// Create custom constructors
func ErrDatabaseError(operation string, cause error) *errs.Error {
    return errs.NewError(CodeDatabaseError, 
        fmt.Sprintf("database %s failed", operation), 
        cause).WithContext("operation", operation).(*errs.Error)
}

// Or implement interfaces for custom types
type DatabaseError struct {
    Query     string
    Table     string
    Operation string
    Err       error
}

func (e *DatabaseError) Error() string {
    return fmt.Sprintf("%s on %s failed: %v", e.Operation, e.Table, e.Err)
}

func (e *DatabaseError) Unwrap() error { return e.Err }
func (e *DatabaseError) Cause() error  { return e.Err }
func (e *DatabaseError) GetCode() string { return CodeDatabaseError }

func (e *DatabaseError) StatusCode() int {
    return http.StatusInternalServerError
}
Dependencies

### External
- Standard library `errors` package
- Standard library `time` package
- Standard library `net/http` package (for HTTP status constants)

### Internal
None - standalone, zero-dependency
        // Extract details if ForgeError
        var forgeErr *errors.ForgeError
        if errors.As(err, &forgeErr) {
            return ctx.JSON(statusCode, forge.Map{
                "error": forgeErr.Message,
                "code":  forgeErr.Code,
    Generic Service Layer Errors
```go
func (s *UserService) GetUser(id string) (*User, error) {
    user, err := s.db.QueryUser(id)
    if err == sql.ErrNoRows {
        return nil, errs.ErrNotFound("user").
            WithContext("user_id", id).(*errs.Error)
    }
    if err != nil {
        return nil, errs.ErrInternal("query failed", err).
            WithContext("operation", "query_user").
            WithContext("user_id", id).(*errs.Error

No configuration required - this is a pure utility package.

## Dependencies

### External
- Standard library `errors` package
- StandavalidationErrs []error
    
    if user.Email == "" {
        validationErrs = append(validationErrs, 
            errs.ErrInvalidInput("email", "email is required"))
    }
    if user.Age < 0 {
        validationErrs = append(validationErrs, 
            errs.ErrInvalidInput("age", "age must be positive"))
    }
    
    if len(validationErrs) > 0 {
        return errs.Join(validationErrs...)
    }
    return nil
}
```

### Timeout Handling
```go
func callExternalAPI(ctx context.Context) error {
    ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
    defer cancel()
    
    result := make(chan error, 1)
    go func() {
        result <- doAPICall()
    }()
    
    select {
    case err := <-result:
        return err
    case <-ctx.Done():
        return errs.ErrTimeoutrValidationError("age", 
            fmt.Errorf("age must be positive")))
    }
    
    if len(errs) > 0 {
        return errors.Join(errs...)
    }
    return nil - just return errors
func repository() error {
    return databaseCall() // Just return, don't log
}

func service() error {
    return repository() // Just return, don't log
}

// Log at boundaries (handlers, main functions)
func handler(w http.ResponseWriter, r *http.Request) {
    err := service()
    if err != nil {
        // Log with full context at boundary
        var structuredErr *errs.Error
        if errs.As(err, &structuredErr) {
            log.Printf("Service error: code=%s, message=%s, context=%+v",
                structuredErr.Code,
                structuredErr.Message,
                structuredErr.Ctx,
            )
        } else {
            log.Printf("Error: %v", err)
        }
        
        statusCode := errs.GetHTTPStatusCode(err)
        http.Error(w, err.Error(), statusCode)
        return
    }
    // success handling
}
```

### Error Logging at Boundaries
This is a standalone, generic error handling package designed to be used across multiple projects.

Potential consumers:
- Web frameworks and HTTP routers
- CLI applications
- Microservices
- Database access layers
- Any Go project requiring structured error handling
    return repository() // Just return, don't log
}

// Log at boundaries (controllers, main)
func handler(ctx forge.Context) error {
    err := service()
    if err != nil {
        // Log with full context at boundary
        var forgeErr *errors.ForgeError
        if errors.As(err, &forgeErr) {
            ctx.Logger().Error("Service error", 
                "code", forgeErr.Code,
                "message", forgeErr.Message,
                "context", forgeErr.Context,
            )
        }
        return err
    }
    return nil
}
```**Use interfaces** - Program against interfaces for maximum flexibility
2. **Use constructor functions** - They ensure consistency
3. **Add context liberally** - Use WithContext() for debugging
4. **Check error chains** - Always use Is() and As()
5. **Log errors only at boundaries** - Don't log at every layer
6. **Always preserve underlying errors** - Use error wrapping
7. **Use typed errors** - Leverage CodedError for programmatic handling
8. **Use sentinel errors** - For common conditions
9. **Extend with custom codes** - Add domain-specific error codes
10. **Implement interfaces** - Create custom types implementing core interfaces

### License
MIT License
### Production Readiness
- ✅ Production-ready with comprehensive testing
- ✅ Full compatibility with Go 1.13+ error handling
- ✅ Thread-safe (errors are immutable after creation)
- ✅ Zero allocation error checks with sentinel errors
- ✅ Rich context without performance penalty

### Performance Characteristics
- Error creation: ~200ns (with context)
- Error checking with Is: ~50ns
- Error type extraction with As: ~100ns
- Zero allocations for sentinel error checks
- Efficient error chain traversal

### Security Considerations
- Never log sensitive data in error context
- Use WithContext judiciously in production
- Sanitize error messages returned to clients
- Don't expose internal structure in HTTP errors
- Consider using error codes instead of messages for clients

### Best Practices
1. Use constructor functions for consistency
2. Add context for debugging, not in production logs
3. Check error chains with Is() and As()
4. Log errors only at boundaries
5. Always preserve underlying errors with wrapping
6. Use typed errors for programmatic handling
7. Use sentinel errors for common conditions

### License
MIT License - Part of Forge Framework

